package interfaces

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"log"
	"net/http"
	"time"

	"github.com/krevetkou/test-ozon/app/models"
)

// CreateComment is the resolver for the CreateComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID *string, commentID *string, comment string) (*models.CommentResponse, error) {
	var com *models.Comment
	if postID != nil {
		p, err := r.PostService.GetPostByID(*postID)
		if err != nil {
			log.Println("Post doesn't exist: ", err)
			return &models.CommentResponse{
				Message: "Post doesn't exist, error creating comment",
				Status:  http.StatusInternalServerError,
			}, nil
		}

		if p.CanBeCommented == false {
			log.Println("Post can't be commented: ", err)
			return &models.CommentResponse{
				Message: "Post can't be commented",
				Status:  http.StatusInternalServerError,
			}, nil
		}

		var comms []*models.Comment
		comms = append(comms, &models.Comment{Comment: comment})

		post := &models.Post{
			ID:       *postID,
			Comments: comms,
		}

		_, err = r.PostService.UpdatePost(post)

		if err != nil {
			log.Println("Comment creation error: ", err)
			return &models.CommentResponse{
				Message: "Error creating comment",
				Status:  http.StatusInternalServerError,
			}, nil
		}

		return &models.CommentResponse{
			Message: "Successfully created comment",
			Status:  http.StatusCreated,
		}, nil
	} else {
		_, err := r.CommentService.IsCommentExists(*commentID)
		if err != nil {
			log.Println("Comment doesn't exist: ", err)
			return &models.CommentResponse{
				Message: "Comment doesn't exist",
				Status:  http.StatusInternalServerError,
			}, nil
		}

		com = &models.Comment{
			CommentID: commentID,
			Comment:   comment,
			CreatedAt: time.Now(),
		}

	}

	comm, err := r.CommentService.UpdateComment(com)
	if err != nil {
		log.Println("Comment creation error: ", err)
		return &models.CommentResponse{
			Message: "Error creating comment",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	return &models.CommentResponse{
		Message: "Successfully created comment",
		Status:  http.StatusCreated,
		Data:    comm,
	}, nil
}

// UpdateComment is the resolver for the UpdateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, id string, comment models.CommentInput) (*models.CommentResponse, error) {
	com, err := r.CommentService.GetCommentByID(id)
	if err != nil {
		return &models.CommentResponse{
			Message: "Error getting the comment",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	com.Comment = comment.Comment

	comm, err := r.CommentService.UpdateComment(com)
	if err != nil {
		return &models.CommentResponse{
			Message: "Error creating comment",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	return &models.CommentResponse{
		Message: "Successfully added comment",
		Status:  http.StatusOK,
		Data:    comm,
	}, nil
}

// IsCommentExists is the resolver for the IsCommentExists field.
func (r *queryResolver) IsCommentExists(ctx context.Context, id string) (bool, error) {
	_, err := r.CommentService.IsCommentExists(id)
	if err != nil {
		log.Println("getting comment error or comment doesn't exist: ", err)
		return false, err
	}

	return true, nil
}

// GetCommentByID is the resolver for the GetCommentByID field.
func (r *queryResolver) GetCommentByID(ctx context.Context, id string) (*models.CommentResponse, error) {
	com, err := r.CommentService.GetCommentByID(id)
	if err != nil {
		log.Println("getting comment error: ", err)
		return &models.CommentResponse{
			Message: "Something went wrong getting the comment",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	return &models.CommentResponse{
		Message: "Successfully retrieved comment",
		Status:  http.StatusOK,
		Data:    com,
	}, nil
}
